<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Penguin Battle! PvP</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  height: 100vh;
  height: 100dvh;
  font-family: 'Segoe UI', sans-serif;
  overflow: hidden;
  touch-action: none;
  overscroll-behavior: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
canvas {
  border: 3px solid #4a90d9;
  border-radius: 8px;
  box-shadow: 0 0 30px rgba(74, 144, 217, 0.3);
  touch-action: none;
}

/* Lobby overlay */
#lobby {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 27, 51, 0.95);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 20;
  gap: 16px;
  touch-action: none;
}
#lobby.hidden { display: none; }
#lobby h1 {
  color: #fff;
  font-size: 32px;
  margin-bottom: 4px;
}
#lobby .subtitle {
  color: #aaccff;
  font-size: 16px;
  margin-bottom: 20px;
}
#lobby input {
  width: 200px;
  padding: 14px;
  font-size: 28px;
  text-align: center;
  border-radius: 12px;
  border: 2px solid #4a90d9;
  background: #1a2a4e;
  color: #fff;
  letter-spacing: 8px;
  font-family: 'Courier New', monospace;
  outline: none;
  touch-action: auto;
  -webkit-user-select: text;
  user-select: text;
}
#lobby input::placeholder {
  letter-spacing: 2px;
  font-size: 16px;
  color: #667;
}
#lobby button {
  width: 200px;
  padding: 14px;
  font-size: 18px;
  font-weight: bold;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  touch-action: none;
}
#join-btn {
  background: #4a90d9;
  color: #fff;
}
#join-btn:active { background: #3a70b0; }
#join-btn:disabled {
  background: #334;
  color: #667;
  cursor: not-allowed;
}
#create-btn {
  background: #2ecc71;
  color: #fff;
}
#create-btn:active { background: #27ae60; }
#create-btn:disabled {
  background: #334;
  color: #667;
  cursor: not-allowed;
}
#copy-btn {
  padding: 8px 14px;
  font-size: 14px;
  border-radius: 8px;
  border: 2px solid #4a90d9;
  background: #1a2a4e;
  color: #aaccff;
  cursor: pointer;
  vertical-align: middle;
}
.lobby-btns {
  display: flex;
  gap: 10px;
}
.lobby-guide {
  color: #99aabb;
  font-size: 12px;
  text-align: center;
  max-width: 320px;
  line-height: 1.6;
}
#lobby .status-msg {
  color: #ffdd44;
  font-size: 16px;
  min-height: 24px;
  text-align: center;
  max-width: 300px;
}
#lobby .error-msg {
  color: #ff6b6b;
  font-size: 14px;
  min-height: 20px;
  text-align: center;
  max-width: 300px;
}

/* Mobile controls */
#mobile-controls {
  display: flex;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 160px;
  justify-content: space-between;
  align-items: flex-end;
  padding: 0 10px 15px;
  pointer-events: none;
  z-index: 10;
}
.dpad {
  pointer-events: auto;
  position: relative;
  width: 140px;
  height: 140px;
}
.dpad-btn {
  position: absolute;
  width: 48px;
  height: 48px;
  background: rgba(255,255,255,0.15);
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  color: rgba(255,255,255,0.7);
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}
.dpad-btn.pressed {
  background: rgba(255,255,255,0.35);
  border-color: rgba(255,255,255,0.6);
}
.dpad-up    { left: 46px; top: 0; }
.dpad-left  { left: 0;    top: 46px; }
.dpad-right { left: 92px; top: 46px; }
.attack-buttons {
  pointer-events: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-end;
}
.atk-btn {
  width: 72px;
  height: 44px;
  border-radius: 12px;
  border: 2px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}
.atk-btn.pressed {
  filter: brightness(1.4);
  transform: scale(0.95);
}
.atk-slap  { background: rgba(74,144,217,0.4);  border-color: rgba(74,144,217,0.7); }
.atk-slide { background: rgba(244,166,35,0.4);   border-color: rgba(244,166,35,0.7); }
.atk-flop  { background: rgba(217,74,74,0.4);    border-color: rgba(217,74,74,0.7); }

/* Rules box */
#rules-box {
  margin-top: -8px;
  padding: 10px 16px;
  background: rgba(255,255,255,0.06);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
  text-align: center;
}
.rules-title {
  color: rgba(255,255,255,0.5);
  font-size: 11px;
  font-weight: bold;
  letter-spacing: 3px;
  margin-bottom: 6px;
}
.rules-row {
  font-size: 13px;
  margin: 3px 0;
  color: rgba(255,255,255,0.7);
}
.r-slap { color: #6eb5ff; font-weight: bold; }
.r-strike { color: #f4a623; font-weight: bold; }
.r-guard { color: #ff6b6b; font-weight: bold; }
.r-arrow { color: rgba(255,255,255,0.3); margin: 0 2px; }
.r-desc { color: rgba(255,255,255,0.35); font-size: 11px; margin-left: 4px; }

/* Keybind button & overlay */
#keybind-btn {
  position: fixed;
  top: 8px;
  left: 8px;
  width: 72px;
  height: 44px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  background: rgba(74,144,217,0.4);
  border: 2px solid rgba(74,144,217,0.7);
  cursor: pointer;
  z-index: 15;
  display: none;
}
#keybind-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 100;
  justify-content: center;
  align-items: center;
}
#keybind-overlay.show { display: flex; }
#keybind-box {
  background: #1a2a4e;
  border: 2px solid #4a90d9;
  border-radius: 12px;
  padding: 24px 32px;
  color: #fff;
  font-family: 'Segoe UI', sans-serif;
  max-width: 340px;
  width: 90%;
}
#keybind-box h3 { margin: 0 0 12px; color: #58a6ff; font-size: 16px; text-align: center; }
.kb-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 14px; }
.kb-row .kb-action { color: #8b949e; }
.kb-row .kb-key { color: #fff; font-family: 'Courier New', monospace; }
#keybind-box .kb-close { display: block; margin: 16px auto 0; padding: 6px 24px; border-radius: 8px; border: 1px solid #4a90d9; background: transparent; color: #58a6ff; cursor: pointer; font-size: 14px; }

/* Solo link */
#solo-link {
  display: inline-block;
  width: 200px;
  padding: 14px;
  font-size: 18px;
  font-weight: bold;
  border-radius: 12px;
  border: 2px solid rgba(170,204,255,0.4);
  background: transparent;
  color: #aaccff;
  text-decoration: none;
  text-align: center;
  box-sizing: border-box;
  transition: border-color 0.2s, color 0.2s;
}
#solo-link:hover { border-color: #aaccff; color: #fff; }

/* Version label */
#version-label {
  position: fixed;
  bottom: 8px;
  right: 12px;
  color: rgba(255,255,255,0.3);
  font-size: 11px;
  font-family: 'Courier New', monospace;
}

/* Connection status */
#conn-status {
  position: fixed;
  top: 8px;
  right: 8px;
  padding: 4px 10px;
  border-radius: 8px;
  font-size: 12px;
  color: #fff;
  z-index: 15;
  background: rgba(0,0,0,0.5);
}
</style>
</head>
<body>
<canvas id="game" width="800" height="500"></canvas>

<div id="lobby">
  <h1>PENGUIN BATTLE!</h1>
  <div class="subtitle">- Online PvP -</div>
  <div class="lobby-guide">PC / スマホ どちらでも対戦できます</div>
  <div class="lobby-guide">1人目:「ルーム作成」でコードを発行し相手に伝える<br>2人目: コードを入力して「参加」</div>
  <div class="lobby-btns">
    <button id="create-btn">ルーム作成</button>
  </div>
  <input id="room-input" type="text" maxlength="6" autocapitalize="characters" style="text-transform:uppercase" placeholder="コード入力">
  <button id="copy-btn" style="display:none" title="コピー">コードをコピー</button>
  <button id="join-btn" disabled>参加</button>
  <div class="status-msg" id="status-msg"></div>
  <div class="error-msg" id="error-msg"></div>
  <div id="rules-box">
    <div class="rules-title">RULES</div>
    <div class="rules-row"><span class="r-slap">SLAP</span> <span class="r-arrow">&gt;</span> <span class="r-guard">GUARD</span> <span class="r-desc">貫通する</span></div>
    <div class="rules-row"><span class="r-strike">STRIKE</span> <span class="r-arrow">&gt;</span> <span class="r-slap">SLAP</span> <span class="r-desc">高ダメージ</span></div>
    <div class="rules-row"><span class="r-guard">GUARD</span> <span class="r-arrow">&gt;</span> <span class="r-strike">STRIKE</span> <span class="r-desc">防御+反撃</span></div>
  </div>
  <a href="../mobile/" id="solo-link">1人で遊ぶ (vs NPC)</a>
  <div id="version-label">v2.6.0</div>
</div>

<button id="keybind-btn">Keys</button>
<div id="keybind-overlay">
  <div id="keybind-box">
    <h3>PC Keybinds</h3>
    <div class="kb-row"><span class="kb-action">Move</span><span class="kb-key">&larr; &rarr; / A D</span></div>
    <div class="kb-row"><span class="kb-action">Jump</span><span class="kb-key">&uarr; / W</span></div>
    <div class="kb-row"><span class="kb-action">SLAP</span><span class="kb-key">Z / J</span></div>
    <div class="kb-row"><span class="kb-action">STRIKE</span><span class="kb-key">X / K</span></div>
    <div class="kb-row"><span class="kb-action">GUARD</span><span class="kb-key">C / L</span></div>
    <button class="kb-close" id="keybind-close">OK</button>
  </div>
</div>

<div id="mobile-controls">
  <div class="dpad">
    <div class="dpad-btn dpad-up" data-dir="up">&#9650;</div>
    <div class="dpad-btn dpad-left" data-dir="left">&#9664;</div>
    <div class="dpad-btn dpad-right" data-dir="right">&#9654;</div>
  </div>
  <div class="attack-buttons">
    <div class="atk-btn atk-slap" data-atk="0">SLAP</div>
    <div class="atk-btn atk-slide" data-atk="1">STRIKE</div>
    <div class="atk-btn atk-flop" data-atk="2">GUARD</div>
  </div>
</div>

<div id="conn-status">接続中...</div>

<script>
// ===== CONFIG =====
const WS_URL = 'wss://d1sclhnq4ipuor.cloudfront.net';

// ===== DOM =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const lobbyEl = document.getElementById('lobby');
const roomInput = document.getElementById('room-input');
const joinBtn = document.getElementById('join-btn');
const statusMsg = document.getElementById('status-msg');
const errorMsg = document.getElementById('error-msg');
const connStatus = document.getElementById('conn-status');
const createBtn = document.getElementById('create-btn');
const copyBtn = document.getElementById('copy-btn');
const keybindBtn = document.getElementById('keybind-btn');
const keybindOverlay = document.getElementById('keybind-overlay');
const keybindClose = document.getElementById('keybind-close');

// ===== GAME STATE =====
const STATE = { LOBBY: -1, BATTLE: 1, WIN: 2, LOSE: 3, DRAW: 4 };
let gameState = STATE.LOBBY;
let shakeTimer = 0, shakeIntensity = 0;
let particles = [], damageTexts = [];
let battleStartTimer = 0;
let myRole = ''; // 'p1' or 'p2'
let roomCode = '';
let frameCount = 0;
const BATTLE_TIME_LIMIT = 60; // seconds
let battleStartTime = 0; // Date.now() when battle actually starts
let battleTimeUp = false; // true if match ended by timeout
const WAITING_TIMEOUT = 300; // 5 minutes waiting timeout (seconds)
let waitingStartTime = 0;
let waitingTimerInterval = null;

// ===== DOUBLE-TAP ZOOM PREVENTION (iOS Safari) =====
// touch-action: none alone is insufficient on iOS Safari 14+
// This global handler prevents double-tap zoom by intercepting rapid taps
let lastTouchEnd = 0;
document.addEventListener('touchstart', (e) => {
  // Prevent double-tap zoom on ALL elements except the text input
  if (e.target.tagName === 'INPUT') return;
  if (e.touches.length > 1) { e.preventDefault(); } // Prevent pinch zoom
}, { passive: false });
document.addEventListener('touchend', (e) => {
  if (e.target.tagName === 'INPUT') return;
  const now = Date.now();
  if (now - lastTouchEnd < 300) {
    e.preventDefault(); // Prevent double-tap zoom
  }
  lastTouchEnd = now;
}, { passive: false });
// Prevent gesturestart (Safari pinch/zoom)
document.addEventListener('gesturestart', (e) => { e.preventDefault(); }, { passive: false });

// ===== KEYS & TOUCH =====
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  // Don't prevent default for input fields (allows backspace, delete, etc.)
  if (document.activeElement && document.activeElement.tagName === 'INPUT') return;
  e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

const touchState = { left: false, right: false, up: false, atk: -1 };

// ===== CANVAS SCALING =====
function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const controlsH = 160;
  const availH = h - controlsH;
  const scale = Math.min(w / 800, availH / 500);
  canvas.style.width = (800 * scale) + 'px';
  canvas.style.height = (500 * scale) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ===== TOUCH CONTROLS =====
document.querySelectorAll('.dpad-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  const onDown = (e) => { e.preventDefault(); touchState[dir] = true; btn.classList.add('pressed'); };
  const onUp = (e) => { e.preventDefault(); touchState[dir] = false; btn.classList.remove('pressed'); };
  btn.addEventListener('touchstart', onDown, { passive: false });
  btn.addEventListener('touchend', onUp, { passive: false });
  btn.addEventListener('touchcancel', onUp, { passive: false });
});

document.querySelectorAll('.atk-btn').forEach(btn => {
  const atk = parseInt(btn.dataset.atk);
  btn.addEventListener('touchstart', (e) => { e.preventDefault(); touchState.atk = atk; btn.classList.add('pressed'); }, { passive: false });
  btn.addEventListener('touchend', (e) => { e.preventDefault(); touchState.atk = -1; btn.classList.remove('pressed'); }, { passive: false });
  btn.addEventListener('touchcancel', (e) => { e.preventDefault(); touchState.atk = -1; btn.classList.remove('pressed'); }, { passive: false });
});

// ===== LOBBY UI =====
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // 紛らわしい文字(0/O, 1/I)を除外
  let code = '';
  for (let i = 0; i < 6; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

let isComposing = false;
roomInput.addEventListener('compositionstart', () => { isComposing = true; });
roomInput.addEventListener('compositionend', () => {
  isComposing = false;
  // Trigger cleanup after composition finishes
  const v = roomInput.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 6);
  roomInput.value = v;
  joinBtn.disabled = v.length !== 6 || !ws || ws.readyState !== WebSocket.OPEN;
  errorMsg.textContent = '';
});
roomInput.addEventListener('input', () => {
  if (isComposing) return; // Skip during IME composition (iOS Japanese input)
  const v = roomInput.value.replace(/[^A-Za-z0-9]/g, '').toUpperCase().slice(0, 6);
  roomInput.value = v;
  joinBtn.disabled = v.length !== 6 || !ws || ws.readyState !== WebSocket.OPEN;
  errorMsg.textContent = '';
});

createBtn.addEventListener('click', () => {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  const code = generateRoomCode();
  roomInput.value = code;
  roomCode = code;
  ws.send(JSON.stringify({ action: 'join', room: roomCode }));
  joinBtn.disabled = true;
  createBtn.disabled = true;
  copyBtn.style.display = 'inline-block';
  statusMsg.textContent = '接続中...';
  errorMsg.textContent = '';
});

copyBtn.addEventListener('click', () => {
  navigator.clipboard.writeText(roomInput.value).then(() => {
    copyBtn.textContent = 'コピーしました!';
    setTimeout(() => { copyBtn.textContent = 'コードをコピー'; }, 1500);
  });
});

joinBtn.addEventListener('click', () => {
  roomCode = roomInput.value;
  if (roomCode.length === 6 && ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ action: 'join', room: roomCode }));
    joinBtn.disabled = true;
    createBtn.disabled = true;
    statusMsg.textContent = '接続中...';
    errorMsg.textContent = '';
  }
});

// ===== WEBSOCKET =====
let ws = null;
let reconnectTimer = null;

function connectWS() {
  if (ws && ws.readyState <= 1) return;
  connStatus.textContent = '接続中...';
  connStatus.style.background = 'rgba(200,150,0,0.5)';

  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    connStatus.textContent = '接続済み';
    connStatus.style.background = 'rgba(0,150,0,0.5)';
    joinBtn.disabled = roomInput.value.length !== 6;
    createBtn.disabled = false;
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    handleServerMessage(msg);
  };

  ws.onclose = () => {
    connStatus.textContent = '切断';
    connStatus.style.background = 'rgba(200,0,0,0.5)';
    joinBtn.disabled = true;
    createBtn.disabled = true;
    clearWaitingTimer();
    statusMsg.style.color = '';
    if (gameState === STATE.BATTLE) {
      // Connection lost during battle
      gameState = STATE.WIN;
      statusMsg.textContent = '相手が切断しました';
    }
    // Auto-reconnect
    clearTimeout(reconnectTimer);
    reconnectTimer = setTimeout(connectWS, 2000);
  };

  ws.onerror = () => {
    connStatus.textContent = 'エラー';
    connStatus.style.background = 'rgba(200,0,0,0.5)';
  };
}

function clearWaitingTimer() {
  if (waitingTimerInterval) {
    clearInterval(waitingTimerInterval);
    waitingTimerInterval = null;
  }
  waitingStartTime = 0;
}

function startWaitingCountdown(room) {
  clearWaitingTimer();
  waitingStartTime = Date.now();
  const updateWaitingDisplay = () => {
    const elapsed = Math.floor((Date.now() - waitingStartTime) / 1000);
    const remaining = WAITING_TIMEOUT - elapsed;
    if (remaining <= 0) {
      // Timeout — release room and return to lobby
      clearWaitingTimer();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'cancel', room: roomCode }));
      }
      errorMsg.textContent = '待機がタイムアウトしました';
      statusMsg.textContent = '';
      joinBtn.disabled = roomInput.value.length !== 6 || !ws || ws.readyState !== WebSocket.OPEN;
      createBtn.disabled = !ws || ws.readyState !== WebSocket.OPEN;
      return;
    }
    const min = Math.floor(remaining / 60);
    const sec = remaining % 60;
    const timeStr = `${min}:${String(sec).padStart(2, '0')}`;
    statusMsg.textContent = `ルーム ${room} で相手を待っています... (${timeStr})`;
    if (remaining <= 30) {
      statusMsg.style.color = '#ff6b6b';
    } else {
      statusMsg.style.color = '';
    }
  };
  updateWaitingDisplay();
  waitingTimerInterval = setInterval(updateWaitingDisplay, 1000);
}

function handleServerMessage(msg) {
  switch (msg.type) {
    case 'waiting':
      startWaitingCountdown(msg.room);
      break;

    case 'start':
      clearWaitingTimer();
      statusMsg.style.color = '';
      if (msg.ttl !== undefined && msg.ttl < 60) {
        statusMsg.textContent = '接続の有効期限が近いです。部屋を作り直してください。';
        statusMsg.style.color = '#ff6666';
        break;
      }
      myRole = msg.you;
      copyBtn.style.display = 'none';
      keybindBtn.style.display = 'block';
      lobbyEl.classList.add('hidden');
      gameState = STATE.BATTLE;
      resetBattle();
      break;

    case 'state': {
      // Full authoritative state from opponent — apply directly
      lastRemoteState = msg;
      break;
    }

    case 'damage': {
      const target = msg.target === myRole ? myPenguin() : opponentPenguin();
      const attacker = msg.target === myRole ? opponentPenguin() : myPenguin();
      target.takeDamage(msg.dmg, attacker.x);
      // Show "COUNTER!" text when GUARD reflects STRIKE
      if (msg.countered) {
        damageTexts.push({
          x: target.x, y: target.y - 60,
          text: 'COUNTER!', life: 50, vy: -1.5,
          color: '#ff4444'
        });
      }
      break;
    }

    case 'end':
      if (msg.winner === 'draw') {
        gameState = STATE.DRAW;
      } else {
        gameState = msg.winner === myRole ? STATE.WIN : STATE.LOSE;
      }
      if (msg.timeup) battleTimeUp = true;
      break;

    case 'opponent_disconnected':
      if (gameState === STATE.BATTLE) {
        gameState = STATE.WIN;
      }
      break;

    case 'error':
      clearWaitingTimer();
      statusMsg.style.color = '';
      errorMsg.textContent = msg.message || 'エラーが発生しました';
      statusMsg.textContent = '';
      joinBtn.disabled = roomInput.value.length !== 6;
      createBtn.disabled = false;
      break;
  }
}

connectWS();

// ===== REMOTE STATE =====
// Full state received from opponent, applied directly
let lastRemoteState = null;

// ===== PENGUIN CLASS =====
class Penguin {
  constructor(x, y, isLocal) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.vx = 0;
    this.vy = 0;
    this.width = 40;
    this.height = 50;
    this.isLocal = isLocal;
    this.facing = isLocal ? 1 : -1;
    this.hp = 100;
    this.maxHp = 100;
    this.attackTimer = 0;
    this.attackCooldown = 0;
    this.isAttacking = false;
    this.attackType = 0;
    this.hitTimer = 0;
    this.grounded = false;
    this.animTimer = 0;
    this.slideTimer = 0;
    this.invincible = 0;
    this._hitSent = false;
  }

  update(other) {
    this.animTimer += 0.1;
    if (this.attackCooldown > 0) this.attackCooldown--;
    if (this.invincible > 0) this.invincible--;
    if (this.hitTimer > 0) this.hitTimer--;
    if (this.slideTimer > 0) this.slideTimer--;

    this.vy += 0.6;
    this.y += this.vy;
    this.x += this.vx;

    const ground = 400;
    if (this.y >= ground) {
      this.y = ground;
      this.vy = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }

    if (this.slideTimer <= 0) {
      this.vx *= 0.85;
    } else {
      this.vx *= 0.97;
    }

    if (this.x < 30) this.x = 30;
    if (this.x > 770) this.x = 770;

    if (!this.isAttacking || this.attackType !== 1) {
      this.facing = other.x > this.x ? 1 : -1;
    }

    if (this.isAttacking) {
      this.attackTimer--;
      if (this.attackTimer <= 0) {
        this.isAttacking = false;
      }
    }
  }

  // Remote penguin update: only timers and animation, no physics
  // Position/velocity/attack state come from state sync
  updateRemote(other) {
    this.animTimer += 0.1;
    if (this.invincible > 0) this.invincible--;
    if (this.hitTimer > 0) this.hitTimer--;

    // Between state syncs, simulate physics for smooth interpolation
    this.vy += 0.6;
    this.y += this.vy;
    this.x += this.vx;

    const ground = 400;
    if (this.y >= ground) {
      this.y = ground;
      this.vy = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }

    if (this.slideTimer <= 0) {
      this.vx *= 0.85;
    } else {
      this.vx *= 0.97;
    }

    if (this.x < 30) this.x = 30;
    if (this.x > 770) this.x = 770;

    // Attack timer ticks down locally for smooth animation
    if (this.isAttacking) {
      this.attackTimer--;
      if (this.attackTimer <= 0) {
        this.isAttacking = false;
      }
    }
    if (this.attackCooldown > 0) this.attackCooldown--;
    if (this.slideTimer > 0) this.slideTimer--;
  }

  attack(type) {
    if (this.attackCooldown > 0 || this.isAttacking) return;
    this.isAttacking = true;
    this.attackType = type;
    this._hitSent = false; // Clear hit flag for new attack
    switch (type) {
      case 0: // SLAP — fast, low damage, pierces GUARD
        this.attackTimer = 10;
        this.attackCooldown = 15;
        break;
      case 1: // STRIKE — slow, high damage, blocked by GUARD
        this.attackTimer = 22;
        this.attackCooldown = 40;
        this.vx = this.facing * 8;
        this.slideTimer = 22;
        break;
      case 2: // GUARD — defensive stance, counters STRIKE, weak to SLAP
        this.attackTimer = 25;
        this.attackCooldown = 30;
        // No movement impulse — stay in place
        break;
    }
  }

  getAttackBox() {
    if (!this.isAttacking) return null;
    switch (this.attackType) {
      case 0: // SLAP — wider and taller hitbox
        return { x: this.x + this.facing * 22, y: this.y - 18, w: 40, h: 35 };
      case 1: // STRIKE — wider hitbox for slide attack
        return { x: this.x + this.facing * 10, y: this.y + 5, w: 55, h: 35 };
      case 2: // GUARD — no attack hitbox
        return null;
    }
  }

  takeDamage(dmg, fromX) {
    if (this.invincible > 0) return;
    this.hp -= dmg;
    if (this.hp < 0) this.hp = 0;
    this.hitTimer = 10;
    this.invincible = 15;
    this.vx = (this.x > fromX ? 1 : -1) * 5;
    this.vy = -4;

    shakeTimer = 8;
    shakeIntensity = dmg * 0.4;

    for (let i = 0; i < 8; i++) {
      particles.push({
        x: this.x, y: this.y - 20,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 1) * 6,
        life: 20 + Math.random() * 15,
        color: this.isLocal ? '#6ec6ff' : '#ff6e6e',
        size: 3 + Math.random() * 4
      });
    }

    damageTexts.push({
      x: this.x, y: this.y - 40,
      text: Math.floor(dmg).toString(),
      life: 40, vy: -2, color: '#ffdd44'
    });
  }

  draw() {
    const px = this.x, py = this.y, f = this.facing;
    ctx.save();
    ctx.translate(px, py);

    if (this.hitTimer > 0 && this.hitTimer % 4 < 2) ctx.globalAlpha = 0.5;
    if (this.invincible > 0 && this.invincible % 6 < 3) ctx.globalAlpha = 0.7;
    if (this.slideTimer > 0) ctx.rotate(f * 0.3);

    const wobble = Math.sin(this.animTimer * 2) * 2;

    // Body
    ctx.fillStyle = this.isLocal ? '#2d2d3d' : '#3d2d2d';
    ctx.beginPath();
    ctx.ellipse(0, -22 + wobble, 18, 25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.ellipse(0, -18 + wobble, 11, 18, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    const eyeY = -32 + wobble;
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.ellipse(f * 5 - 3, eyeY, 5, 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(f * 5 + 5, eyeY, 5, 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.ellipse(f * 5 - 3 + f * 2, eyeY, 2.5, 3, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(f * 5 + 5 + f * 2, eyeY, 2.5, 3, 0, 0, Math.PI * 2); ctx.fill();

    // Beak
    ctx.fillStyle = '#f4a623';
    ctx.beginPath();
    ctx.moveTo(f * 12, -28 + wobble);
    ctx.lineTo(f * 22, -25 + wobble);
    ctx.lineTo(f * 12, -22 + wobble);
    ctx.closePath();
    ctx.fill();

    // Flippers
    const flapAngle = this.isAttacking && this.attackType === 0
      ? f * -1.2 : Math.sin(this.animTimer * 3) * 0.2;
    ctx.save();
    ctx.translate(-14, -25 + wobble);
    ctx.rotate(flapAngle - 0.3);
    ctx.fillStyle = this.isLocal ? '#2d2d3d' : '#3d2d2d';
    ctx.beginPath(); ctx.ellipse(0, 10, 5, 14, -0.2, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(14, -25 + wobble);
    ctx.rotate(-flapAngle + 0.3);
    ctx.fillStyle = this.isLocal ? '#2d2d3d' : '#3d2d2d';
    ctx.beginPath(); ctx.ellipse(0, 10, 5, 14, 0.2, 0, Math.PI * 2); ctx.fill();
    ctx.restore();

    // Feet
    ctx.fillStyle = '#f4a623';
    ctx.beginPath(); ctx.ellipse(-8, 2, 8, 4, -0.2, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(8, 2, 8, 4, 0.2, 0, Math.PI * 2); ctx.fill();

    // Label
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    if (this.isLocal) {
      ctx.fillStyle = '#4a90d9';
      ctx.fillText('YOU', 0, -55);
      ctx.beginPath(); ctx.moveTo(0, -50); ctx.lineTo(-5, -45); ctx.lineTo(5, -45); ctx.closePath(); ctx.fill();
    } else {
      ctx.fillStyle = '#d94a4a';
      ctx.fillText('RIVAL', 0, -55);
    }

    // Attack effects
    if (this.isAttacking) {
      ctx.globalAlpha = 0.6;
      if (this.attackType === 0) {
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
        for (let i = 0; i < 3; i++) {
          const baseAngle = -0.5 + i * 0.3; // spread angles
          const startX = f * 20;
          const endX = startX + f * Math.abs(Math.cos(baseAngle)) * 22;
          const endY = -25 + Math.sin(baseAngle) * 22;
          ctx.beginPath(); ctx.moveTo(startX, -25);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }
      } else if (this.attackType === 1) {
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.arc(-f * 15 + Math.random() * 10, 5 + Math.random() * 5, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (this.attackType === 2) {
        // GUARD: shield bubble effect
        const pulse = Math.sin(this.attackTimer * 0.5) * 0.15 + 0.45;
        ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, -15, 30, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = `rgba(255, 100, 100, ${pulse * 0.2})`;
        ctx.beginPath(); ctx.arc(0, -15, 30, 0, Math.PI * 2); ctx.fill();
      }
    }
    ctx.restore();
  }
}

// ===== GAME OBJECTS =====
let localPenguin, remotePenguin;

function myPenguin() { return localPenguin; }
function opponentPenguin() { return remotePenguin; }

function resetBattle() {
  // p1 is left, p2 is right
  if (myRole === 'p1') {
    localPenguin = new Penguin(200, 400, true);
    remotePenguin = new Penguin(600, 400, false);
  } else {
    localPenguin = new Penguin(600, 400, true);
    remotePenguin = new Penguin(200, 400, false);
  }
  particles = [];
  damageTexts = [];
  battleStartTimer = 90;
  frameCount = 0;
  battleStartTime = 0; // Will be set when countdown ends
  battleTimeUp = false;
}

// Initial penguins for pre-lobby rendering
localPenguin = new Penguin(200, 400, true);
remotePenguin = new Penguin(600, 400, false);

// ===== DRAWING FUNCTIONS =====
function drawHPBar(x, y, w, h, hp, maxHp, color, label) {
  const ratio = hp / maxHp;
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, w, h);
  const barColor = ratio > 0.5 ? color : ratio > 0.25 ? '#f4a623' : '#d94a4a';
  ctx.fillStyle = barColor;
  ctx.fillRect(x, y, w * ratio, h);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);
  ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(label, x, y - 5);
  ctx.textAlign = 'center';
  ctx.fillText(`${Math.ceil(hp)} / ${maxHp}`, x + w / 2, y + h - 4);
}

function drawBackground() {
  const grad = ctx.createLinearGradient(0, 0, 0, 500);
  grad.addColorStop(0, '#0f1b33');
  grad.addColorStop(0.6, '#1a3a5c');
  grad.addColorStop(1, '#2a5a8c');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 800, 500);

  ctx.fillStyle = '#fff';
  for (let i = 0; i < 30; i++) {
    const sx = (i * 137 + 50) % 800;
    const sy = (i * 97 + 20) % 250;
    const ss = 1 + (i % 3);
    ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.002 + i) * 0.3;
    ctx.beginPath(); ctx.arc(sx, sy, ss, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  const snowGrad = ctx.createLinearGradient(0, 400, 0, 500);
  snowGrad.addColorStop(0, '#e8f0ff');
  snowGrad.addColorStop(1, '#b8d0f0');
  ctx.fillStyle = snowGrad;
  ctx.beginPath();
  ctx.moveTo(0, 410);
  for (let x = 0; x <= 800; x += 20) {
    ctx.lineTo(x, 405 + Math.sin(x * 0.03) * 5);
  }
  ctx.lineTo(800, 500);
  ctx.lineTo(0, 500);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = 'rgba(180, 220, 255, 0.3)';
  ctx.fillRect(50, 360, 40, 45);
  ctx.fillRect(710, 365, 35, 40);
  ctx.fillStyle = 'rgba(160, 210, 255, 0.2)';
  ctx.fillRect(380, 370, 50, 35);
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life / 30;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function updateDamageTexts() {
  for (let i = damageTexts.length - 1; i >= 0; i--) {
    const dt = damageTexts[i];
    dt.y += dt.vy; dt.life--;
    if (dt.life <= 0) { damageTexts.splice(i, 1); continue; }
    ctx.globalAlpha = dt.life / 40;
    ctx.fillStyle = dt.color;
    ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(dt.text, dt.x, dt.y);
  }
  ctx.globalAlpha = 1;
}

// ===== INPUT & NETWORK =====
const STATE_SYNC_INTERVAL = 3; // send full state every N frames (~20/sec at 60fps)

function handleLocalInput() {
  if (localPenguin.hitTimer > 0) {
    // Still send state even when hit-stunned so opponent sees knockback
    sendStateToServer();
    return;
  }

  const inp = {
    left: !!(keys['ArrowLeft'] || keys['a'] || touchState.left),
    right: !!(keys['ArrowRight'] || keys['d'] || touchState.right),
    up: !!(keys['ArrowUp'] || keys['w'] || touchState.up),
    atk: (keys['z'] || keys['j']) ? 0
       : (keys['x'] || keys['k']) ? 1
       : (keys['c'] || keys['l']) ? 2
       : touchState.atk,
  };

  // Apply locally
  if (inp.left) localPenguin.vx -= 1.0;
  if (inp.right) localPenguin.vx += 1.0;
  if (inp.up && localPenguin.grounded) localPenguin.vy = -12;
  if (inp.atk >= 0) localPenguin.attack(inp.atk);
  if (Math.abs(localPenguin.vx) > 5) localPenguin.vx = 5 * Math.sign(localPenguin.vx);

  // Send full state periodically
  sendStateToServer();
}

function sendStateToServer() {
  if (frameCount % STATE_SYNC_INTERVAL !== 0) return;
  if (!ws || ws.readyState !== WebSocket.OPEN) return;

  const lp = localPenguin;
  ws.send(JSON.stringify({
    action: 'state',
    room: roomCode,
    x: Math.round(lp.x * 10) / 10,
    y: Math.round(lp.y * 10) / 10,
    vx: Math.round(lp.vx * 100) / 100,
    vy: Math.round(lp.vy * 100) / 100,
    atk: lp.attackType,
    atkT: lp.attackTimer,
    isAtk: lp.isAttacking ? 1 : 0,
    atkCd: lp.attackCooldown,
    slideT: lp.slideTimer,
    hp: Math.round(lp.hp * 10) / 10,
    f: frameCount,
    gr: lp.grounded ? 1 : 0,
    face: lp.facing,
  }));
}

function applyRemoteState() {
  if (!lastRemoteState) return;
  const msg = lastRemoteState;
  const rp = remotePenguin;

  // Position & velocity: snap to authoritative values
  rp.x = msg.x;
  rp.y = msg.y;
  rp.vx = msg.vx;
  rp.vy = msg.vy;

  // Attack state: sync fully
  if (msg.isAtk) {
    // Opponent is attacking — sync their attack state
    if (!rp.isAttacking || rp.attackType !== msg.atk) {
      // New attack started or different attack type
      rp.isAttacking = true;
      rp.attackType = msg.atk;
    }
    rp.attackTimer = msg.atkT;
  } else {
    rp.isAttacking = false;
    rp.attackTimer = 0;
  }
  rp.attackCooldown = msg.atkCd;
  rp.slideTimer = msg.slideT;
  rp.grounded = !!msg.gr;
  rp.facing = msg.face;

  // HP sync (server-authoritative damage will override, but this keeps display in sync)
  // Only sync if remote reports lower HP (don't override server damage)
  if (msg.hp < rp.hp) {
    rp.hp = msg.hp;
  }

  // Clear after applying
  lastRemoteState = null;
}

// ===== ATTACK HIT DETECTION =====
function checkAttacks(attacker, defender) {
  // Only local player reports hits
  if (!attacker.isLocal) return;
  if (!attacker.isAttacking) return;
  if (attacker.attackType === 2) return; // GUARD has no offensive hitbox
  if (attacker._hitSent) return; // Already hit this attack

  // No timer window restriction — if the attack is active, it can hit.
  // The _hitSent flag ensures only one hit per attack.
  // This is maximally generous: any frame during the attack animation can register a hit.

  // Simple distance-based hit check
  const dx = Math.abs(attacker.x + attacker.facing * 15 - defender.x);
  const dy = Math.abs(attacker.y - defender.y);
  const hitRange = attacker.attackType === 1 ? 75 : 60;
  const hitRangeY = 55;

  if (dx < hitRange && dy < hitRangeY) {
    attacker._hitSent = true;

    if (ws && ws.readyState === WebSocket.OPEN) {
      // Check rock-paper-scissors: STRIKE vs active GUARD = countered
      const isCountered = attacker.attackType === 1 &&
                          defender.isAttacking && defender.attackType === 2;

      ws.send(JSON.stringify({
        action: 'hit',
        room: roomCode,
        attackType: attacker.attackType,
        countered: isCountered ? 1 : 0,
      }));
    }
  }
}

// ===== MAIN GAME LOOP =====
function gameLoop() {
  ctx.save();

  if (shakeTimer > 0) {
    shakeTimer--;
    ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
    shakeIntensity *= 0.85;
  }

  drawBackground();

  if (gameState === STATE.LOBBY) {
    // Just draw background, lobby overlay handles UI
  } else if (gameState === STATE.BATTLE) {
    updateBattle();
  } else if (gameState === STATE.WIN || gameState === STATE.LOSE || gameState === STATE.DRAW) {
    drawResult();
  }

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

function updateBattle() {
  if (battleStartTimer > 0) {
    battleStartTimer--;
    if (battleStartTimer === 0) {
      battleStartTime = Date.now(); // Start the clock when countdown ends
    }
    localPenguin.draw();
    remotePenguin.draw();
    drawHPBar(30, 25, 250, 22, localPenguin.hp, localPenguin.maxHp, '#4a90d9', 'YOU');
    drawHPBar(520, 25, 250, 22, remotePenguin.hp, remotePenguin.maxHp, '#d94a4a', 'RIVAL');

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 60px sans-serif';
    ctx.textAlign = 'center';
    if (battleStartTimer > 60) ctx.fillText('3', 400, 250);
    else if (battleStartTimer > 30) ctx.fillText('2', 400, 250);
    else ctx.fillText('1', 400, 250);
    return;
  }

  frameCount++;

  // Calculate remaining time (real-time based, FPS-independent)
  const elapsed = (Date.now() - battleStartTime) / 1000;
  const remaining = Math.max(0, BATTLE_TIME_LIMIT - elapsed);
  const remainSec = Math.ceil(remaining);

  handleLocalInput();
  applyRemoteState();

  // IMPORTANT: Check attacks BEFORE update() so that:
  // 1. The attack is still in its active state (isAttacking=true)
  // 2. update() hasn't decremented attackTimer to 0 yet (which clears isAttacking)
  // This ensures every frame of the attack animation can register a hit.
  checkAttacks(localPenguin, remotePenguin);
  checkAttacks(remotePenguin, localPenguin);

  localPenguin.update(remotePenguin);
  remotePenguin.updateRemote(localPenguin);

  localPenguin.draw();
  remotePenguin.draw();
  updateParticles();
  updateDamageTexts();

  drawHPBar(30, 25, 250, 22, localPenguin.hp, localPenguin.maxHp, '#4a90d9', 'YOU');
  drawHPBar(520, 25, 250, 22, remotePenguin.hp, remotePenguin.maxHp, '#d94a4a', 'RIVAL');

  // Draw timer
  drawTimer(remainSec);

  // Time up check
  if (remaining <= 0) {
    battleTimeUp = true;
    const myHp = localPenguin.hp;
    const theirHp = remotePenguin.hp;
    const opponentRole = myRole === 'p1' ? 'p2' : 'p1';

    if (myHp > theirHp) {
      gameState = STATE.WIN;
      spawnConfetti();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'end', room: roomCode, winner: myRole, timeup: 1 }));
      }
    } else if (theirHp > myHp) {
      gameState = STATE.LOSE;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'end', room: roomCode, winner: opponentRole, timeup: 1 }));
      }
    } else {
      // Exact tie
      gameState = STATE.DRAW;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'end', room: roomCode, winner: 'draw', timeup: 1 }));
      }
    }
    return;
  }

  // Win/lose check (KO)
  if (remotePenguin.hp <= 0) {
    gameState = STATE.WIN;
    spawnConfetti();
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ action: 'end', room: roomCode, winner: myRole }));
    }
  }
  if (localPenguin.hp <= 0) {
    gameState = STATE.LOSE;
    const opponentRole = myRole === 'p1' ? 'p2' : 'p1';
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ action: 'end', room: roomCode, winner: opponentRole }));
    }
  }
}

function drawTimer(remainSec) {
  ctx.save();
  ctx.font = 'bold 28px sans-serif';
  ctx.textAlign = 'center';
  // Flash red when under 10 seconds
  if (remainSec <= 10) {
    ctx.fillStyle = Math.sin(Date.now() * 0.01) > 0 ? '#ff4444' : '#ff8888';
  } else {
    ctx.fillStyle = '#fff';
  }
  ctx.fillText(remainSec, 400, 25);
  ctx.restore();
}

function spawnConfetti() {
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: 400 + (Math.random() - 0.5) * 300, y: 200,
      vx: (Math.random() - 0.5) * 10,
      vy: -Math.random() * 8 - 3,
      life: 60 + Math.random() * 40,
      color: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a8e6cf', '#ff8a80', '#80d8ff'][Math.floor(Math.random() * 6)],
      size: 3 + Math.random() * 5
    });
  }
}

function drawResult() {
  localPenguin.draw();
  remotePenguin.draw();
  updateParticles();
  updateDamageTexts();

  drawHPBar(30, 25, 250, 22, localPenguin.hp, localPenguin.maxHp, '#4a90d9', 'YOU');
  drawHPBar(520, 25, 250, 22, remotePenguin.hp, remotePenguin.maxHp, '#d94a4a', 'RIVAL');

  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 130, 800, 230);

  ctx.textAlign = 'center';

  // Show TIME UP! if the match ended by timeout
  if (battleTimeUp) {
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = '#ffaa44';
    ctx.fillText('TIME UP!', 400, 175);
  }

  ctx.font = 'bold 50px sans-serif';

  if (gameState === STATE.WIN) {
    ctx.fillStyle = '#4ecdc4';
    ctx.fillText('YOU WIN!', 400, 230);
    ctx.font = '20px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText('Your penguin is victorious!', 400, 270);
  } else if (gameState === STATE.LOSE) {
    ctx.fillStyle = '#ff6b6b';
    ctx.fillText('YOU LOSE...', 400, 230);
    ctx.font = '20px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText('Better luck next time...', 400, 270);
  } else if (gameState === STATE.DRAW) {
    ctx.fillStyle = '#ffdd44';
    ctx.fillText('DRAW', 400, 230);
    ctx.font = '20px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText('Both penguins survived!', 400, 270);
  }

  ctx.font = 'bold 18px sans-serif';
  ctx.fillStyle = '#ffdd44';
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillText('Tap to return to Lobby', 400, 330);
  }

  // Tap/click to return to lobby
  if (keys[' '] || keys['Enter']) {
    returnToLobby();
  }
}

// Always prevent default on canvas touch (prevents iOS double-tap zoom)
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameState === STATE.WIN || gameState === STATE.LOSE || gameState === STATE.DRAW) {
    returnToLobby();
  }
}, { passive: false });
canvas.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });

function returnToLobby() {
  clearWaitingTimer();
  gameState = STATE.LOBBY;
  lobbyEl.classList.remove('hidden');
  copyBtn.style.display = 'none';
  keybindBtn.style.display = 'none';
  keybindOverlay.classList.remove('show');
  statusMsg.textContent = '';
  statusMsg.style.color = '';
  errorMsg.textContent = '';
  // Keep room code for easy rematch — pre-fill input with last room
  if (roomCode && roomCode.length === 6) {
    roomInput.value = roomCode;
  }
  joinBtn.disabled = roomInput.value.length !== 6 || !ws || ws.readyState !== WebSocket.OPEN;
  createBtn.disabled = !ws || ws.readyState !== WebSocket.OPEN;
  roomCode = '';
  myRole = '';
  lastRemoteState = null;
}

// ===== KEYBIND OVERLAY =====
keybindBtn.addEventListener('click', () => { keybindOverlay.classList.add('show'); });
keybindClose.addEventListener('click', () => { keybindOverlay.classList.remove('show'); });
keybindOverlay.addEventListener('click', (e) => { if (e.target === keybindOverlay) keybindOverlay.classList.remove('show'); });

// ===== BACK NAVIGATION GUARD =====
// Prevent accidental browser-back during battle
function pushGuardState() {
  history.pushState({ guard: true }, '');
}
pushGuardState();
window.addEventListener('popstate', (e) => {
  if (gameState !== STATE.LOBBY) {
    // During battle/waiting: block back navigation
    pushGuardState();
  }
  // In lobby: allow normal behavior (do nothing, state already popped)
});
window.addEventListener('beforeunload', (e) => {
  if (gameState !== STATE.LOBBY) {
    e.preventDefault();
  }
});

// ===== START =====
gameLoop();
</script>
</body>
</html>
