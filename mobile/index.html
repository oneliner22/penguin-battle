<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Penguin Battle! - vs NPC</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  height: 100vh;
  height: 100dvh;
  font-family: 'Segoe UI', sans-serif;
  overflow: hidden;
  touch-action: none;
  overscroll-behavior: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}
canvas {
  border: 3px solid #4a90d9;
  border-radius: 8px;
  box-shadow: 0 0 30px rgba(74, 144, 217, 0.3);
  touch-action: none;
}
#mobile-controls {
  display: flex;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 160px;
  justify-content: space-between;
  align-items: flex-end;
  padding: 0 10px 15px;
  pointer-events: none;
  z-index: 10;
}
.dpad {
  pointer-events: auto;
  position: relative;
  width: 140px;
  height: 140px;
}
.dpad-btn {
  position: absolute;
  width: 48px;
  height: 48px;
  background: rgba(255,255,255,0.15);
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  color: rgba(255,255,255,0.7);
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}
.dpad-btn.pressed {
  background: rgba(255,255,255,0.35);
  border-color: rgba(255,255,255,0.6);
}
.dpad-up    { left: 46px; top: 0; }
.dpad-left  { left: 0;    top: 46px; }
.dpad-right { left: 92px; top: 46px; }
.attack-buttons {
  pointer-events: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-end;
}
.atk-btn {
  width: 72px;
  height: 44px;
  border-radius: 12px;
  border: 2px solid;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  color: #fff;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}
.atk-btn.pressed {
  filter: brightness(1.4);
  transform: scale(0.95);
}
.atk-slap   { background: rgba(74,144,217,0.4);  border-color: rgba(74,144,217,0.7); }
.atk-strike { background: rgba(244,166,35,0.4);   border-color: rgba(244,166,35,0.7); }
.atk-guard  { background: rgba(217,74,74,0.4);    border-color: rgba(217,74,74,0.7); }
/* Keybind button & overlay */
#keybind-btn {
  position: fixed;
  top: 8px;
  left: 8px;
  padding: 4px 10px;
  border-radius: 8px;
  font-size: 12px;
  color: #aaccff;
  background: rgba(0,0,0,0.5);
  border: 1px solid rgba(74,144,217,0.4);
  cursor: pointer;
  z-index: 15;
}
#keybind-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  z-index: 100;
  justify-content: center;
  align-items: center;
}
#keybind-overlay.show { display: flex; }
#keybind-box {
  background: #1a2a4e;
  border: 2px solid #4a90d9;
  border-radius: 12px;
  padding: 24px 32px;
  color: #fff;
  font-family: 'Segoe UI', sans-serif;
  max-width: 340px;
  width: 90%;
}
#keybind-box h3 { margin: 0 0 12px; color: #58a6ff; font-size: 16px; text-align: center; }
.kb-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 14px; }
.kb-row .kb-action { color: #8b949e; }
.kb-row .kb-key { color: #fff; font-family: 'Courier New', monospace; }
#keybind-box .kb-close { display: block; margin: 16px auto 0; padding: 6px 24px; border-radius: 8px; border: 1px solid #4a90d9; background: transparent; color: #58a6ff; cursor: pointer; font-size: 14px; }
</style>
</head>
<body>
<canvas id="game" width="800" height="500"></canvas>
<div id="mobile-controls">
  <div class="dpad">
    <div class="dpad-btn dpad-up" data-dir="up">&#9650;</div>
    <div class="dpad-btn dpad-left" data-dir="left">&#9664;</div>
    <div class="dpad-btn dpad-right" data-dir="right">&#9654;</div>
  </div>
  <div class="attack-buttons">
    <div class="atk-btn atk-slap" data-atk="0">SLAP</div>
    <div class="atk-btn atk-strike" data-atk="1">STRIKE</div>
    <div class="atk-btn atk-guard" data-atk="2">GUARD</div>
  </div>
</div>
<button id="keybind-btn">Keys</button>
<div id="keybind-overlay">
  <div id="keybind-box">
    <h3>PC Keybinds</h3>
    <div class="kb-row"><span class="kb-action">Move</span><span class="kb-key">&larr; &rarr; / A D</span></div>
    <div class="kb-row"><span class="kb-action">Jump</span><span class="kb-key">&uarr; / W</span></div>
    <div class="kb-row"><span class="kb-action">SLAP</span><span class="kb-key">Z / J</span></div>
    <div class="kb-row"><span class="kb-action">STRIKE</span><span class="kb-key">X / K</span></div>
    <div class="kb-row"><span class="kb-action">GUARD</span><span class="kb-key">C / L</span></div>
    <button class="kb-close" id="keybind-close">OK</button>
  </div>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Game State
const STATE = { TITLE: 0, BATTLE: 1, WIN: 2, LOSE: 3, DRAW: 4 };
let gameState = STATE.TITLE;
let shakeTimer = 0;
let shakeIntensity = 0;
let particles = [];
let damageTexts = [];
let battleStartTimer = 0;

const BATTLE_TIME_LIMIT = 60;
let battleStartTime = 0;
let battleTimeUp = false;

// Keys (for keyboard fallback)
const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key] = false; });

// Touch state
const touchState = { left: false, right: false, up: false, atk: -1 };

// Canvas scaling
function resizeCanvas() {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const controlsH = 160;
  const availH = h - controlsH;
  const scale = Math.min(w / 800, availH / 500);
  canvas.style.width = (800 * scale) + 'px';
  canvas.style.height = (500 * scale) + 'px';
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// D-pad touch handling
document.querySelectorAll('.dpad-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  const onDown = (e) => { e.preventDefault(); touchState[dir] = true; btn.classList.add('pressed'); };
  const onUp = (e) => { e.preventDefault(); touchState[dir] = false; btn.classList.remove('pressed'); };
  btn.addEventListener('touchstart', onDown, { passive: false });
  btn.addEventListener('touchend', onUp, { passive: false });
  btn.addEventListener('touchcancel', onUp, { passive: false });
});

// Attack button touch handling
document.querySelectorAll('.atk-btn').forEach(btn => {
  const atk = parseInt(btn.dataset.atk);
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    touchState.atk = atk;
    btn.classList.add('pressed');
  }, { passive: false });
  btn.addEventListener('touchend', (e) => {
    e.preventDefault();
    touchState.atk = -1;
    btn.classList.remove('pressed');
  }, { passive: false });
  btn.addEventListener('touchcancel', (e) => {
    e.preventDefault();
    touchState.atk = -1;
    btn.classList.remove('pressed');
  }, { passive: false });
});

// Tap on canvas for start/retry
let tapAction = false;
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameState === STATE.TITLE || gameState === STATE.WIN || gameState === STATE.LOSE || gameState === STATE.DRAW) {
    tapAction = true;
  }
}, { passive: false });

// Seeded PRNG (mulberry32) for damage calculation
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

let gameSeed = 0;
let hitCount = 0;

function calcDamage(attackType, countered) {
  if (countered) return 5;
  hitCount++;
  const rng = mulberry32(gameSeed + hitCount * 7919);
  const r = rng();
  switch (attackType) {
    case 0: return 6 + r * 4;   // SLAP: 6-10
    case 1: return 14 + r * 6;  // STRIKE: 14-20
    default: return 0;
  }
}

// Penguin class
class Penguin {
  constructor(x, y, isPlayer) {
    this.x = x;
    this.y = y;
    this.baseY = y;
    this.vx = 0;
    this.vy = 0;
    this.width = 40;
    this.height = 50;
    this.isPlayer = isPlayer;
    this.facing = isPlayer ? 1 : -1;
    this.hp = 100;
    this.maxHp = 100;
    this.attackTimer = 0;
    this.attackCooldown = 0;
    this.isAttacking = false;
    this.attackType = 0;
    this.hitTimer = 0;
    this.grounded = false;
    this.animTimer = 0;
    this.slideTimer = 0;
    this.invincible = 0;
    this._hitSent = false;
    // NPC AI
    this.aiTimer = 0;
    this.aiAction = 'idle';
  }

  update(other) {
    this.animTimer += 0.1;
    if (this.attackCooldown > 0) this.attackCooldown--;
    if (this.invincible > 0) this.invincible--;
    if (this.hitTimer > 0) this.hitTimer--;
    if (this.slideTimer > 0) this.slideTimer--;

    // Gravity
    this.vy += 0.6;
    this.y += this.vy;
    this.x += this.vx;

    // Ground
    const ground = 400;
    if (this.y >= ground) {
      this.y = ground;
      this.vy = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }

    // Friction
    if (this.slideTimer <= 0) {
      this.vx *= 0.85;
    } else {
      this.vx *= 0.97;
    }

    // Walls
    if (this.x < 30) this.x = 30;
    if (this.x > 770) this.x = 770;

    // Face opponent
    if (!this.isAttacking || this.attackType !== 1) {
      this.facing = other.x > this.x ? 1 : -1;
    }

    // Attack animation
    if (this.isAttacking) {
      this.attackTimer--;
      if (this.attackTimer <= 0) {
        this.isAttacking = false;
      }
    }

    // AI control
    if (!this.isPlayer) {
      this.updateAI(other);
    }
  }

  updateAI(player) {
    this.aiTimer--;
    const dist = Math.abs(this.x - player.x);

    if (this.aiTimer <= 0) {
      this.aiTimer = 15 + Math.random() * 25;

      if (dist > 200) {
        this.aiAction = 'approach';
      } else if (dist < 80) {
        // Close range: react to player state
        if (player.isAttacking && player.attackType === 1) {
          // Player using STRIKE: GUARD to counter
          this.aiAction = Math.random() < 0.6 ? 'guard' : 'retreat';
        } else if (player.isAttacking && player.attackType === 2) {
          // Player GUARDing: SLAP pierces
          this.aiAction = Math.random() < 0.6 ? 'slap' : 'approach';
        } else {
          const r = Math.random();
          if (r < 0.3) this.aiAction = 'slap';
          else if (r < 0.5) this.aiAction = 'strike';
          else if (r < 0.65) this.aiAction = 'guard';
          else if (r < 0.8) this.aiAction = 'retreat';
          else this.aiAction = 'approach';
        }
      } else if (dist < 150) {
        // Mid range
        const r = Math.random();
        if (r < 0.25) this.aiAction = 'approach';
        else if (r < 0.45) this.aiAction = 'strike';
        else if (r < 0.6) this.aiAction = 'slap';
        else if (r < 0.7) this.aiAction = 'jump_attack';
        else this.aiAction = 'guard';
      } else {
        this.aiAction = Math.random() < 0.6 ? 'approach' : 'idle';
      }
    }

    switch (this.aiAction) {
      case 'approach':
        this.vx += this.facing * 0.8;
        break;
      case 'retreat':
        this.vx -= this.facing * 1.0;
        if (this.grounded && Math.random() < 0.1) this.vy = -10;
        break;
      case 'slap':
        if (dist < 70 && this.attackCooldown <= 0) {
          this.attack(0);
          this.aiAction = 'idle';
        } else {
          this.vx += this.facing * 0.5;
        }
        break;
      case 'strike':
        if (this.attackCooldown <= 0 && this.grounded) {
          this.attack(1);
          this.aiAction = 'idle';
        }
        break;
      case 'guard':
        if (this.attackCooldown <= 0) {
          this.attack(2);
          this.aiAction = 'idle';
        }
        break;
      case 'jump_attack':
        if (this.grounded) this.vy = -11;
        if (dist < 80 && this.attackCooldown <= 0) {
          this.attack(0);
          this.aiAction = 'idle';
        }
        break;
    }

    // Clamp speed
    if (Math.abs(this.vx) > 5) this.vx = 5 * Math.sign(this.vx);
  }

  attack(type) {
    if (this.attackCooldown > 0 || this.isAttacking) return;
    this.isAttacking = true;
    this.attackType = type;
    this._hitSent = false;
    switch (type) {
      case 0: // SLAP — fast, low damage, pierces GUARD
        this.attackTimer = 10;
        this.attackCooldown = 15;
        break;
      case 1: // STRIKE — slow, high damage, blocked by GUARD
        this.attackTimer = 22;
        this.attackCooldown = 40;
        this.vx = this.facing * 8;
        this.slideTimer = 22;
        break;
      case 2: // GUARD — defensive stance, counters STRIKE, weak to SLAP
        this.attackTimer = 25;
        this.attackCooldown = 30;
        break;
    }
  }

  getAttackBox() {
    if (!this.isAttacking) return null;
    switch (this.attackType) {
      case 0:
        return { x: this.x + this.facing * 22, y: this.y - 18, w: 40, h: 35 };
      case 1:
        return { x: this.x + this.facing * 10, y: this.y + 5, w: 55, h: 35 };
      case 2:
        return null; // GUARD has no offensive hitbox
    }
  }

  takeDamage(dmg, fromX) {
    if (this.invincible > 0) return;
    this.hp -= dmg;
    if (this.hp < 0) this.hp = 0;
    this.hitTimer = 10;
    this.invincible = 15;
    this.vx = (this.x > fromX ? 1 : -1) * 5;
    this.vy = -4;

    shakeTimer = 8;
    shakeIntensity = dmg * 0.4;

    // Particles
    for (let i = 0; i < 8; i++) {
      particles.push({
        x: this.x, y: this.y - 20,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 1) * 6,
        life: 20 + Math.random() * 15,
        color: this.isPlayer ? '#6ec6ff' : '#ff6e6e',
        size: 3 + Math.random() * 4
      });
    }

    // Damage text
    damageTexts.push({
      x: this.x, y: this.y - 40,
      text: Math.floor(dmg).toString(),
      life: 40, vy: -2, color: '#ffdd44'
    });
  }

  draw() {
    const px = this.x;
    const py = this.y;
    const f = this.facing;

    ctx.save();
    ctx.translate(px, py);

    // Flash when hit
    if (this.hitTimer > 0 && this.hitTimer % 4 < 2) {
      ctx.globalAlpha = 0.5;
    }
    if (this.invincible > 0 && this.invincible % 6 < 3) {
      ctx.globalAlpha = 0.7;
    }

    // Slide pose
    if (this.slideTimer > 0) {
      ctx.rotate(f * 0.3);
    }

    // Wobble
    const wobble = Math.sin(this.animTimer * 2) * 2;

    // Body (black)
    ctx.fillStyle = this.isPlayer ? '#2d2d3d' : '#3d2d2d';
    ctx.beginPath();
    ctx.ellipse(0, -22 + wobble, 18, 25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly (white)
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.ellipse(0, -18 + wobble, 11, 18, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    const eyeY = -32 + wobble;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(f * 5 - 3, eyeY, 5, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(f * 5 + 5, eyeY, 5, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    // Pupils
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.ellipse(f * 5 - 3 + f * 2, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(f * 5 + 5 + f * 2, eyeY, 2.5, 3, 0, 0, Math.PI * 2);
    ctx.fill();

    // Beak
    ctx.fillStyle = '#f4a623';
    ctx.beginPath();
    ctx.moveTo(f * 12, -28 + wobble);
    ctx.lineTo(f * 22, -25 + wobble);
    ctx.lineTo(f * 12, -22 + wobble);
    ctx.closePath();
    ctx.fill();

    // Flippers
    const flapAngle = this.isAttacking && this.attackType === 0
      ? f * -1.2 : Math.sin(this.animTimer * 3) * 0.2;
    ctx.save();
    ctx.translate(-14, -25 + wobble);
    ctx.rotate(flapAngle - 0.3);
    ctx.fillStyle = this.isPlayer ? '#2d2d3d' : '#3d2d2d';
    ctx.beginPath();
    ctx.ellipse(0, 10, 5, 14, -0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(14, -25 + wobble);
    ctx.rotate(-flapAngle + 0.3);
    ctx.fillStyle = this.isPlayer ? '#2d2d3d' : '#3d2d2d';
    ctx.beginPath();
    ctx.ellipse(0, 10, 5, 14, 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Feet
    ctx.fillStyle = '#f4a623';
    ctx.beginPath();
    ctx.ellipse(-8, 2, 8, 4, -0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(8, 2, 8, 4, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Player indicator
    if (this.isPlayer) {
      ctx.fillStyle = '#4a90d9';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('YOU', 0, -55);
      ctx.beginPath();
      ctx.moveTo(0, -50);
      ctx.lineTo(-5, -45);
      ctx.lineTo(5, -45);
      ctx.closePath();
      ctx.fill();
    } else {
      ctx.fillStyle = '#d94a4a';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('NPC', 0, -55);
    }

    // Attack effects
    if (this.isAttacking) {
      ctx.globalAlpha = 0.6;
      if (this.attackType === 0) {
        // SLAP effect
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
        for (let i = 0; i < 3; i++) {
          const baseAngle = -0.5 + i * 0.3;
          const startX = f * 20;
          const endX = startX + f * Math.abs(Math.cos(baseAngle)) * 22;
          const endY = -25 + Math.sin(baseAngle) * 22;
          ctx.beginPath(); ctx.moveTo(startX, -25);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }
      } else if (this.attackType === 1) {
        // STRIKE sparks
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.arc(-f * 15 + Math.random() * 10, 5 + Math.random() * 5, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      } else if (this.attackType === 2) {
        // GUARD: shield bubble effect
        const pulse = Math.sin(this.attackTimer * 0.5) * 0.15 + 0.45;
        ctx.strokeStyle = `rgba(255, 100, 100, ${pulse})`;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, -15, 30, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = `rgba(255, 100, 100, ${pulse * 0.2})`;
        ctx.beginPath(); ctx.arc(0, -15, 30, 0, Math.PI * 2); ctx.fill();
      }
    }

    ctx.restore();
  }
}

// Player & NPC
let player, npc;

function resetBattle() {
  player = new Penguin(200, 400, true);
  npc = new Penguin(600, 400, false);
  particles = [];
  damageTexts = [];
  battleStartTimer = 90;
  battleStartTime = 0;
  battleTimeUp = false;
  gameSeed = Math.floor(Math.random() * 2147483647);
  hitCount = 0;
}

resetBattle();

// Draw HP bar
function drawHPBar(x, y, w, h, hp, maxHp, color, label) {
  const ratio = hp / maxHp;
  ctx.fillStyle = '#333';
  ctx.fillRect(x, y, w, h);
  const barColor = ratio > 0.5 ? color : ratio > 0.25 ? '#f4a623' : '#d94a4a';
  ctx.fillStyle = barColor;
  ctx.fillRect(x, y, w * ratio, h);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(label, x, y - 5);
  ctx.textAlign = 'center';
  ctx.fillText(`${Math.ceil(hp)} / ${maxHp}`, x + w / 2, y + h - 4);
}

// Draw background
function drawBackground() {
  const grad = ctx.createLinearGradient(0, 0, 0, 500);
  grad.addColorStop(0, '#0f1b33');
  grad.addColorStop(0.6, '#1a3a5c');
  grad.addColorStop(1, '#2a5a8c');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 800, 500);

  ctx.fillStyle = '#fff';
  for (let i = 0; i < 30; i++) {
    const sx = (i * 137 + 50) % 800;
    const sy = (i * 97 + 20) % 250;
    const ss = 1 + (i % 3);
    ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.002 + i) * 0.3;
    ctx.beginPath();
    ctx.arc(sx, sy, ss, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  const snowGrad = ctx.createLinearGradient(0, 400, 0, 500);
  snowGrad.addColorStop(0, '#e8f0ff');
  snowGrad.addColorStop(1, '#b8d0f0');
  ctx.fillStyle = snowGrad;
  ctx.beginPath();
  ctx.moveTo(0, 410);
  for (let x = 0; x <= 800; x += 20) {
    ctx.lineTo(x, 405 + Math.sin(x * 0.03) * 5);
  }
  ctx.lineTo(800, 500);
  ctx.lineTo(0, 500);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = 'rgba(180, 220, 255, 0.3)';
  ctx.fillRect(50, 360, 40, 45);
  ctx.fillRect(710, 365, 35, 40);
  ctx.fillStyle = 'rgba(160, 210, 255, 0.2)';
  ctx.fillRect(380, 370, 50, 35);
}

// Particles update
function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.2;
    p.life--;
    if (p.life <= 0) {
      particles.splice(i, 1);
      continue;
    }
    ctx.globalAlpha = p.life / 30;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// Damage texts update
function updateDamageTexts() {
  for (let i = damageTexts.length - 1; i >= 0; i--) {
    const dt = damageTexts[i];
    dt.y += dt.vy;
    dt.life--;
    if (dt.life <= 0) {
      damageTexts.splice(i, 1);
      continue;
    }
    ctx.globalAlpha = dt.life / 40;
    ctx.fillStyle = dt.color;
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(dt.text, dt.x, dt.y);
  }
  ctx.globalAlpha = 1;
}

// Input handling
function handleInput() {
  if (player.hitTimer > 0) return;

  if (keys['ArrowLeft'] || keys['a'] || touchState.left) {
    player.vx -= 1.0;
  }
  if (keys['ArrowRight'] || keys['d'] || touchState.right) {
    player.vx += 1.0;
  }
  if ((keys['ArrowUp'] || keys['w'] || touchState.up) && player.grounded) {
    player.vy = -12;
  }
  if (keys['z'] || keys['j']) player.attack(0);
  if (keys['x'] || keys['k']) player.attack(1);
  if (keys['c'] || keys['l']) player.attack(2);
  if (touchState.atk >= 0) player.attack(touchState.atk);

  if (Math.abs(player.vx) > 5) player.vx = 5 * Math.sign(player.vx);
}

// Check attack hits (PvP-style distance-based + rock-paper-scissors)
function checkAttacks(attacker, defender) {
  if (!attacker.isAttacking) return;
  if (attacker.attackType === 2) return; // GUARD has no offensive hitbox
  if (attacker._hitSent) return;

  const dx = Math.abs(attacker.x + attacker.facing * 15 - defender.x);
  const dy = Math.abs(attacker.y - defender.y);
  const hitRange = attacker.attackType === 1 ? 75 : 60;
  const hitRangeY = 55;

  if (dx < hitRange && dy < hitRangeY) {
    attacker._hitSent = true;

    // Rock-paper-scissors: STRIKE vs active GUARD = countered
    const isCountered = attacker.attackType === 1 &&
                        defender.isAttacking && defender.attackType === 2;

    const dmg = calcDamage(attacker.attackType, isCountered);
    const target = isCountered ? attacker : defender;
    target.takeDamage(dmg, isCountered ? defender.x : attacker.x);

    if (isCountered) {
      damageTexts.push({
        x: target.x, y: target.y - 60,
        text: 'COUNTER!', life: 50, vy: -1.5,
        color: '#ff4444'
      });
    }
  }
}

// Main loop
function gameLoop() {
  ctx.save();

  if (shakeTimer > 0) {
    shakeTimer--;
    const sx = (Math.random() - 0.5) * shakeIntensity;
    const sy = (Math.random() - 0.5) * shakeIntensity;
    ctx.translate(sx, sy);
    shakeIntensity *= 0.85;
  }

  drawBackground();

  switch (gameState) {
    case STATE.TITLE:
      drawTitle();
      break;
    case STATE.BATTLE:
      updateBattle();
      break;
    case STATE.WIN:
    case STATE.LOSE:
    case STATE.DRAW:
      drawResult();
      break;
  }

  ctx.restore();
  requestAnimationFrame(gameLoop);
}

function drawTitle() {
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('PENGUIN BATTLE!', 400, 150);

  ctx.font = '18px sans-serif';
  ctx.fillStyle = '#aaccff';
  ctx.fillText('- vs NPC -', 400, 185);

  player.animTimer += 0.05;
  npc.animTimer += 0.05;
  player.draw();
  npc.draw();

  ctx.fillStyle = '#ddd';
  ctx.font = '16px sans-serif';
  ctx.fillText('D-pad / Arrow / WASD : Move & Jump', 400, 270);
  ctx.fillText('SLAP(Z) > GUARD(C) > STRIKE(X) > SLAP', 400, 300);
  ctx.font = '13px sans-serif';
  ctx.fillStyle = '#8b949e';
  ctx.fillText('PC / Mobile both supported', 400, 330);

  ctx.font = 'bold 22px sans-serif';
  ctx.fillStyle = '#ffdd44';
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillText('Tap to Start!', 400, 420);
  }

  if (tapAction || keys[' '] || keys['Enter']) {
    tapAction = false;
    keys[' '] = false;
    keys['Enter'] = false;
    gameState = STATE.BATTLE;
    resetBattle();
  }
}

function drawTimer(remainSec) {
  ctx.save();
  ctx.font = 'bold 28px sans-serif';
  ctx.textAlign = 'center';
  if (remainSec <= 10) {
    ctx.fillStyle = Math.sin(Date.now() * 0.01) > 0 ? '#ff4444' : '#ff8888';
  } else {
    ctx.fillStyle = '#fff';
  }
  ctx.fillText(remainSec, 400, 25);
  ctx.restore();
}

function updateBattle() {
  if (battleStartTimer > 0) {
    battleStartTimer--;
    if (battleStartTimer === 0) {
      battleStartTime = Date.now();
    }
    player.draw();
    npc.draw();
    drawHPBar(30, 25, 250, 22, player.hp, player.maxHp, '#4a90d9', 'YOU');
    drawHPBar(520, 25, 250, 22, npc.hp, npc.maxHp, '#d94a4a', 'NPC');

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 60px sans-serif';
    ctx.textAlign = 'center';
    if (battleStartTimer > 60) ctx.fillText('3', 400, 250);
    else if (battleStartTimer > 30) ctx.fillText('2', 400, 250);
    else ctx.fillText('1', 400, 250);
    return;
  }

  const elapsed = (Date.now() - battleStartTime) / 1000;
  const remaining = Math.max(0, BATTLE_TIME_LIMIT - elapsed);
  const remainSec = Math.ceil(remaining);

  handleInput();

  // Check attacks BEFORE update (same as PvP)
  checkAttacks(player, npc);
  checkAttacks(npc, player);

  player.update(npc);
  npc.update(player);

  // Draw
  player.draw();
  npc.draw();
  updateParticles();
  updateDamageTexts();

  drawHPBar(30, 25, 250, 22, player.hp, player.maxHp, '#4a90d9', 'YOU');
  drawHPBar(520, 25, 250, 22, npc.hp, npc.maxHp, '#d94a4a', 'NPC');

  drawTimer(remainSec);

  // Time up check
  if (remaining <= 0) {
    battleTimeUp = true;
    if (player.hp > npc.hp) {
      gameState = STATE.WIN;
      spawnConfetti();
    } else if (npc.hp > player.hp) {
      gameState = STATE.LOSE;
    } else {
      gameState = STATE.DRAW;
    }
    return;
  }

  // KO check
  if (npc.hp <= 0) {
    gameState = STATE.WIN;
    spawnConfetti();
  }
  if (player.hp <= 0) {
    gameState = STATE.LOSE;
  }
}

function spawnConfetti() {
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: 400 + (Math.random() - 0.5) * 300, y: 200,
      vx: (Math.random() - 0.5) * 10,
      vy: -Math.random() * 8 - 3,
      life: 60 + Math.random() * 40,
      color: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#a8e6cf', '#ff8a80', '#80d8ff'][Math.floor(Math.random() * 6)],
      size: 3 + Math.random() * 5
    });
  }
}

function drawResult() {
  player.draw();
  npc.draw();
  updateParticles();
  updateDamageTexts();

  drawHPBar(30, 25, 250, 22, player.hp, player.maxHp, '#4a90d9', 'YOU');
  drawHPBar(520, 25, 250, 22, npc.hp, npc.maxHp, '#d94a4a', 'NPC');

  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 130, 800, 230);

  ctx.textAlign = 'center';

  if (battleTimeUp) {
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = '#ffaa44';
    ctx.fillText('TIME UP!', 400, 175);
  }

  ctx.font = 'bold 50px sans-serif';

  if (gameState === STATE.WIN) {
    ctx.fillStyle = '#4ecdc4';
    ctx.fillText('YOU WIN!', 400, 230);
    ctx.font = '20px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText('Your penguin is victorious!', 400, 270);
  } else if (gameState === STATE.LOSE) {
    ctx.fillStyle = '#ff6b6b';
    ctx.fillText('YOU LOSE...', 400, 230);
    ctx.font = '20px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText('Better luck next time...', 400, 270);
  } else if (gameState === STATE.DRAW) {
    ctx.fillStyle = '#ffdd44';
    ctx.fillText('DRAW', 400, 230);
    ctx.font = '20px sans-serif'; ctx.fillStyle = '#fff';
    ctx.fillText('Both penguins survived!', 400, 270);
  }

  ctx.font = 'bold 18px sans-serif';
  ctx.fillStyle = '#ffdd44';
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillText('Tap to go back', 400, 330);
  }

  if (tapAction || keys[' '] || keys['Enter']) {
    tapAction = false;
    keys[' '] = false;
    keys['Enter'] = false;
    gameState = STATE.TITLE;
    resetBattle();
    keybindOverlay.classList.remove('show');
  }
}

// Keybind overlay
const keybindBtn = document.getElementById('keybind-btn');
const keybindOverlay = document.getElementById('keybind-overlay');
const keybindClose = document.getElementById('keybind-close');
keybindBtn.addEventListener('click', () => { keybindOverlay.classList.add('show'); });
keybindClose.addEventListener('click', () => { keybindOverlay.classList.remove('show'); });
keybindOverlay.addEventListener('click', (e) => { if (e.target === keybindOverlay) keybindOverlay.classList.remove('show'); });

// Start
gameLoop();
</script>
</body>
</html>
